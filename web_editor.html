<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>文档转 URL 编辑台</title>
  <style>
    :root {
      --bg: #ffffff;
      --panel: #ffffff;
      --ink: #1f1a14;
      --muted: #6f6559;
      --border: #e3e3e3;
      --accent: #a35c2b;
      --accent-2: #2f6f64;
      --shadow: 0 10px 24px rgba(0, 0, 0, 0.06);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      background: var(--bg);
      font-family: system-ui, -apple-system, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      min-height: 100vh;
    }
    .app {
      max-width: 1280px;
      margin: 28px auto 32px;
      padding: 0 20px 30px;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 18px;
    }
    header h1 {
      font-size: 22px;
      margin: 0;
      letter-spacing: 0.3px;
    }
    header .sub {
      color: var(--muted);
      font-size: 13px;
    }
    .header-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }
    .board {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    .panel {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      min-height: 420px;
    }
    .panel header {
      padding: 14px 14px 10px;
      margin: 0;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .panel header h2 {
      font-size: 15px;
      margin: 0;
    }
    .panel header .actions {
      display: flex;
      gap: 8px;
    }
    .panel textarea,
    .panel .editor {
      flex: 1;
      border: none;
      outline: none;
      padding: 14px;
      font-size: 14px;
      line-height: 1.7;
      font-family: system-ui, -apple-system, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      color: var(--ink);
      background: transparent;
    }
    .panel textarea { resize: none; }
    .panel .editor {
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .panel .editor:empty:before {
      content: attr(data-placeholder);
      color: var(--muted);
    }
    .panel textarea.html {
      font-size: 13px;
      color: #2b2520;
    }
    .footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      border-top: 1px solid var(--border);
      padding-top: 14px;
    }
    .status {
      color: var(--muted);
      font-size: 13px;
    }
    button {
      border: none;
      padding: 10px 16px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, box-shadow 0.2s ease;
    }
    button:active { transform: translateY(1px); }
    .btn-primary {
      background: var(--accent);
      color: white;
      box-shadow: 0 10px 20px rgba(163, 92, 43, 0.25);
    }
    .btn-secondary {
      background: var(--accent-2);
      color: white;
      box-shadow: 0 10px 20px rgba(47, 111, 100, 0.25);
    }
    .btn-ghost {
      background: #f3ede6;
      color: var(--ink);
      border: 1px solid #e2d9ce;
    }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>文档转 URL 编辑台</h1>
        <div class="sub">左侧粘贴/导入文档（保留加粗/颜色/字号），右侧编辑 HTML</div>
      </div>
      <div class="header-actions">
        <button class="btn-primary" id="btn-generate-html">生成 HTML</button>
        <div class="sub">支持粘贴按钮与快捷键 Ctrl/⌘ + V</div>
      </div>
    </header>

    <div class="board">
      <div class="grid">
        <section class="panel">
          <header>
            <h2>原始文档（自动识别）</h2>
            <div class="actions">
              <button class="btn-ghost" id="btn-import">导入文件</button>
              <button class="btn-ghost" id="btn-paste">粘贴</button>
              <button class="btn-ghost" id="btn-clear">清空</button>
            </div>
          </header>
          <div id="doc-input" class="editor" contenteditable="true" data-placeholder="粘贴或导入 .md / .txt / .docx（.doc 请先另存为 .docx 或 .txt）。富文本粘贴会保留格式。"></div>
        </section>

        <section class="panel">
          <header>
            <h2>HTML 编辑器</h2>
            <div class="actions">
              <button class="btn-ghost" id="btn-copy-html">复制 HTML</button>
            </div>
          </header>
          <textarea id="html-editor" class="html" placeholder="生成后的 HTML 会显示在这里，可继续编辑..."></textarea>
        </section>
      </div>

      <div class="footer">
        <div class="status" id="status">等待输入...</div>
        <div class="actions">
          <button class="btn-primary" id="btn-generate-url">生成 URL</button>
          <button class="btn-secondary" id="btn-replace">替换原文档</button>
        </div>
      </div>
    </div>
  </div>

  <input id="file-input" type="file" accept=".md,.markdown,.txt,.doc,.docx" hidden />

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mammoth/mammoth.browser.min.js"></script>
  <script>
    const docInput = document.getElementById('doc-input');
    const htmlEditor = document.getElementById('html-editor');
    const status = document.getElementById('status');
    let inputType = 'auto';
    let currentUrl = null;
    const fileInput = document.getElementById('file-input');

    function setStatus(message, allowHtml = false) {
      if (allowHtml) {
        status.innerHTML = message;
      } else {
        status.textContent = message;
      }
    }

    function escapeHtml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function detectInputType(text) {
      const trimmed = text.trim();
      if (!trimmed) return 'text';
      if (/<[a-z][\s\S]*>/i.test(trimmed)) {
        return 'html';
      }
      const mdSignals = [
        /^#\s+/m,
        /^\s*[-*+]\s+/m,
        /^\s*\d+\.\s+/m,
        /\*\*.+\*\*/,
        /`{3}[\s\S]*`{3}/,
        /\[[^\]]+\]\([^)]+\)/,
      ];
      const score = mdSignals.reduce((acc, regex) => acc + (regex.test(trimmed) ? 1 : 0), 0);
      return score >= 2 ? 'markdown' : 'text';
    }

    function extractBodyHtml(htmlText) {
      try {
        const doc = new DOMParser().parseFromString(htmlText, 'text/html');
        if (doc && doc.body) {
          return doc.body.innerHTML.trim();
        }
      } catch (err) {
        return htmlText;
      }
      return htmlText;
    }

    function hasRichHtml(htmlText) {
      return /<(strong|b|em|i|u|span|font|a|img|table|sup|sub|code|pre|blockquote)\b/i.test(htmlText)
        || /style=/.test(htmlText);
    }

    function inferTitle(mdText) {
      const lines = mdText.split('\n');
      for (const line of lines) {
        const match = line.trim().match(/^#\s+(.+)$/);
        if (match) {
          return match[1].trim();
        }
      }
      return 'Document';
    }

    function wrapHtml(bodyHtml, title) {
      return `<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>${title}</title>
  <style>
    :root {
      --bg: #ffffff;
      --ink: #1e1b16;
      --muted: #6f6559;
      --border: #e3e3e3;
      --accent: #7a4b2f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      line-height: 1.8;
    }
    .page {
      max-width: 980px;
      margin: 40px auto;
      padding: 48px 56px;
      background: #ffffff;
    }
    h1, h2, h3 { margin: 0 0 12px; color: var(--ink); }
    h1 { font-size: 32px; letter-spacing: 0.5px; }
    h2 { font-size: 22px; margin-top: 28px; border-left: 4px solid var(--accent); padding-left: 10px; }
    h3 { font-size: 18px; margin-top: 22px; color: var(--accent); }
    p { margin: 8px 0; }
    hr { border: none; border-top: 1px solid var(--border); margin: 18px 0; }
    ul, ol { margin: 8px 0 8px 22px; padding: 0; }
    li { margin: 4px 0; }
    blockquote {
      margin: 12px 0;
      padding: 12px 16px;
      background: #fbf7f0;
      border-left: 4px solid var(--accent);
      color: var(--muted);
    }
    strong { color: var(--ink); }
    code {
      background: #f2f2f2;
      padding: 2px 4px;
      border-radius: 4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      color: #2b2520;
    }
    pre {
      background: #f2f2f2;
      padding: 12px 14px;
      border-radius: 6px;
      overflow: auto;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <main class="page">
    ${bodyHtml}
  </main>
</body>
</html>`;
    }

    function normalizeHtml(htmlText, title) {
      const hasDoc = /<!doctype|<html[\s>]/i.test(htmlText);
      return hasDoc ? htmlText : wrapHtml(htmlText, title);
    }

    function textToHtml(text) {
      const safe = escapeHtml(text);
      const chunks = safe.split(/\n{2,}/).map(chunk => chunk.trim()).filter(Boolean);
      if (!chunks.length) return '';
      return chunks.map(chunk => `<p>${chunk.replace(/\n/g, '<br />')}</p>`).join('\n');
    }

    function setDocHtml(htmlText) {
      docInput.innerHTML = extractBodyHtml(htmlText);
    }

    async function readClipboardRich() {
      if (navigator.clipboard && navigator.clipboard.read) {
        try {
          const items = await navigator.clipboard.read();
          for (const item of items) {
            if (item.types.includes('text/html')) {
              const blob = await item.getType('text/html');
              const html = await blob.text();
              return { html };
            }
          }
          for (const item of items) {
            if (item.types.includes('text/plain')) {
              const blob = await item.getType('text/plain');
              const text = await blob.text();
              return { text };
            }
          }
        } catch (err) {
          // fallback below
        }
      }
      if (navigator.clipboard && navigator.clipboard.readText) {
        const text = await navigator.clipboard.readText();
        return { text };
      }
      return null;
    }

    function simpleMarkdown(md) {
      // Fallback: minimal markdown support if CDN is unavailable
      let html = md
        .replace(/\r\n/g, '\n')
        .replace(/^######\s+(.*)$/gm, '<h6>$1</h6>')
        .replace(/^#####\s+(.*)$/gm, '<h5>$1</h5>')
        .replace(/^####\s+(.*)$/gm, '<h4>$1</h4>')
        .replace(/^###\s+(.*)$/gm, '<h3>$1</h3>')
        .replace(/^##\s+(.*)$/gm, '<h2>$1</h2>')
        .replace(/^#\s+(.*)$/gm, '<h1>$1</h1>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/`([^`]+)`/g, '<code>$1</code>');

      html = html.replace(/^(\s*[-*+]\s+.+(?:\n\s*[-*+]\s+.+)*)/gm, (block) => {
        const items = block.split(/\n/).map(line => line.replace(/^\s*[-*+]\s+/, '')).map(item => `<li>${item}</li>`).join('');
        return `<ul>${items}</ul>`;
      });

      html = html.replace(/\n{2,}/g, '\n\n').split('\n\n').map(chunk => {
        if (/^<h\d|^<ul|^<ol|^<blockquote|^<pre|^<p|^<h|^<table/.test(chunk.trim())) {
          return chunk;
        }
        return `<p>${chunk.replace(/\n/g, '<br />')}</p>`;
      }).join('\n');

      return html;
    }

    function formatLabel(type) {
      if (type === 'markdown') return 'Markdown';
      if (type === 'html') return 'HTML';
      return '纯文本';
    }

    function generateHtmlFromInput() {
      const rawText = (docInput.innerText || '').replace(/\u00A0/g, ' ').trim();
      const rawHtml = (docInput.innerHTML || '').trim();
      if (!rawText && !rawHtml) {
        setStatus('左侧没有内容。');
        return null;
      }

      let detected = inputType;
      if (detected === 'auto') {
        if (hasRichHtml(rawHtml)) {
          detected = 'html';
        } else {
          detected = detectInputType(rawText);
        }
      }

      let bodyHtml = '';
      if (detected === 'html') {
        bodyHtml = rawHtml;
      } else if (detected === 'markdown') {
        bodyHtml = window.marked ? window.marked.parse(rawText) : simpleMarkdown(rawText);
      } else {
        bodyHtml = textToHtml(rawText);
      }
      htmlEditor.value = bodyHtml;
      setStatus(`已生成 HTML（识别为 ${formatLabel(detected)}）。`);
      return bodyHtml;
    }

    document.getElementById('btn-generate-html').addEventListener('click', () => {
      generateHtmlFromInput();
    });

    document.getElementById('btn-generate-url').addEventListener('click', () => {
      const raw = (docInput.innerText || '').trim();
      let bodyHtml = htmlEditor.value.trim();
      if (!bodyHtml) {
        bodyHtml = generateHtmlFromInput();
        if (!bodyHtml) return;
      }
      const title = inferTitle(raw);
      const fullHtml = normalizeHtml(bodyHtml, title);
      const blob = new Blob([fullHtml], { type: 'text/html' });
      if (currentUrl) {
        URL.revokeObjectURL(currentUrl);
      }
      currentUrl = URL.createObjectURL(blob);
      setStatus(`URL 已生成：<a href="${currentUrl}" target="_blank" rel="noopener">打开页面</a>`, true);
    });

    document.getElementById('btn-replace').addEventListener('click', () => {
      const html = htmlEditor.value.trim();
      if (!html) {
        setStatus('右侧没有 HTML。');
        return;
      }
      setDocHtml(html);
      inputType = 'html';
      setStatus('已用 HTML 替换原文档。');
    });

    document.getElementById('btn-paste').addEventListener('click', async () => {
      const data = await readClipboardRich();
      if (!data) {
        setStatus('当前浏览器不支持读取剪贴板，请用快捷键粘贴。');
        return;
      }
      if (data.html) {
        setDocHtml(data.html);
        inputType = 'html';
        setStatus('已从剪贴板粘贴（保留格式）。');
        return;
      }
      if (data.text) {
        docInput.innerText = data.text;
        inputType = 'auto';
        setStatus('已从剪贴板粘贴，将自动识别格式。');
        return;
      }
      setStatus('剪贴板为空。');
    });

    document.getElementById('btn-clear').addEventListener('click', () => {
      docInput.innerHTML = '';
      inputType = 'auto';
      setStatus('已清空原始文档。');
    });

    document.getElementById('btn-copy-html').addEventListener('click', async () => {
      const html = htmlEditor.value.trim();
      if (!html) {
        setStatus('右侧没有 HTML。');
        return;
      }
      if (!navigator.clipboard || !navigator.clipboard.writeText) {
        setStatus('当前浏览器不支持复制，请手动复制。');
        return;
      }
      try {
        await navigator.clipboard.writeText(html);
        setStatus('HTML 已复制到剪贴板。');
      } catch (err) {
        setStatus('复制失败，请手动复制。');
      }
    });

    docInput.addEventListener('paste', (event) => {
      if (!event.clipboardData) return;
      const html = event.clipboardData.getData('text/html');
      if (html) {
        event.preventDefault();
        setDocHtml(html);
        inputType = 'html';
        setStatus('已粘贴并保留格式。');
      }
    });

    document.getElementById('btn-import').addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const name = file.name || '';
      const ext = name.split('.').pop().toLowerCase();

      try {
        if (ext === 'md' || ext === 'markdown') {
          const text = await file.text();
          docInput.innerText = text;
          inputType = 'markdown';
          setStatus(`已导入 ${name}（Markdown）。`);
        } else if (ext === 'txt') {
          const text = await file.text();
          docInput.innerText = text;
          inputType = 'text';
          setStatus(`已导入 ${name}（纯文本）。`);
        } else if (ext === 'docx') {
          if (!window.mammoth) {
            setStatus('无法加载 docx 解析组件，请检查网络后重试。');
            return;
          }
          const arrayBuffer = await file.arrayBuffer();
          const htmlResult = await window.mammoth.convertToHtml({ arrayBuffer });
          const htmlValue = htmlResult.value || '';
          setDocHtml(htmlValue);
          htmlEditor.value = htmlValue;
          inputType = 'html';
          setStatus(`已导入 ${name}（docx）：已保留可识别的格式。`);
        } else if (ext === 'doc') {
          setStatus('浏览器无法直接解析 .doc，请另存为 .docx 或 .txt 后再导入。');
        } else {
          setStatus('不支持的文件格式。请使用 .md / .txt / .docx。');
        }
      } catch (err) {
        setStatus('导入失败，请检查文件是否损坏。');
      } finally {
        fileInput.value = '';
      }
    });

    docInput.addEventListener('input', () => {
      if (inputType !== 'auto') {
        inputType = 'auto';
      }
    });
  </script>
</body>
</html>
